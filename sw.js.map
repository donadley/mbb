{"version":3,"sources":["../public/sw.js"],"names":["event","updateWidget","updateName","widgetDefinition","payload","name","request"],"mappings":"AAAA,cACI,yEACJ,EAMA,KAAK,iBAAiB,gBAAkB,GAAU,CAC9C,EAAM,UAAU,EAAa,CAAK,CAAC,CACvC,CAAC,EAGD,KAAK,iBAAiB,eAAiB,GAAU,CAC7C,EAAM,UAAU,EAAa,CAAK,CAAC,CACvC,CAAC,EAID,KAAK,iBAAiB,cAAgB,GAAU,CAC5C,EAAM,QAAU,cAChB,EAAM,UAAU,EAAW,CAAK,CAAC,CAErC,CAAC,EAID,KAAK,iBAAiB,kBAAoB,GAAU,CAAA,CAAE,EAEtD,MAAM,EAAe,MAAO,GAAU,CAElC,MAAM,EAAmB,EAAM,OAAO,WAGhC,EAAU,CACZ,SAAU,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,YAAY,GAAG,MAAM,EAClF,KAAM,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,IAAI,GAAG,MAAM,CACzE,EAGD,MAAM,KAAK,QAAQ,mBAAmB,EAAM,WAAY,CAAO,CACnE,EAEM,EAAa,MAAO,GAAU,CAChC,MAAM,EAAO,EAAM,KAAK,KAAM,EAAC,KAGzB,EAAmB,EAAM,OAAO,WAGhC,EAAU,CACZ,SAAU,KAAK,UAAU,MAAO,MAAM,MAAM,EAAiB,YAAY,GAAG,MAAM,EAClF,KAAM,KAAK,UAAU,CAAC,KAAA,CAAI,CAAC,CAC9B,EAGD,MAAM,KAAK,QAAQ,mBAAmB,EAAM,WAAY,CAAO,CACnE,EAEA,QAAQ,UAAU,CAAE,MAAO,GAAM,EAGjC,QAAQ,QAAQ,cACZ,CAAC,CAAE,QAAA,CAAO,IAAO,EAAQ,OAAS,WAClC,MAAO,CAAE,MAAA,CAAK,IAAO,CACjB,GAAI,CAEA,OAAO,MAAM,QAAQ,WAAW,aAAc,EAAC,OAAO,CAAE,MAAA,EAAO,CAClE,MAAe,CAEZ,OAAO,MAAM,OAAO,MAAM,eAAe,CACrD,CACA,CACA,EAGA,QAAQ,QAAQ,cACZ,CAAC,CAAE,QAAA,CAAS,IACR,CAAC,QAAS,SAAU,OAAO,EAAE,SAAS,EAAQ,WAAW,EAC7D,IAAI,QAAQ,WAAW,WAAW,CAC9B,UAAW,gBACX,QAAS,CACL,IAAI,QAAQ,WAAW,iBAAiB,CACpC,WAAY,GACZ,cAAe,GAAK,GAAK,GAAK,EAC9C,CAAa,CACJ,CACJ,CAAA,CACL,EAEA,QAAQ,WAAW,iBAAiB,+oDAAK,eAAiB,CAAA,CAAE","file":"sw.js","sourcesContent":["importScripts(\n    'https://storage.googleapis.com/workbox-cdn/releases/7.3.0/workbox-sw.js'\n);\n\n// This is your Service Worker, you can put any of your custom Service Worker\n// code in this file, above the `precacheAndRoute` line.\n\n// When widget is installed/pinned, push initial state.\nself.addEventListener('widgetinstall', (event) => {\n    event.waitUntil(updateWidget(event));\n});\n\n// When widget is shown, update content to ensure it is up-to-date.\nself.addEventListener('widgetresume', (event) => {\n    event.waitUntil(updateWidget(event));\n});\n\n// When the user clicks an element with an associated Action.Execute,\n// handle according to the 'verb' in event.action.\nself.addEventListener('widgetclick', (event) => {\nif (event.action == \"updateName\") {\n    event.waitUntil(updateName(event));\n}\n});\n\n// When the widget is uninstalled/unpinned, clean up any unnecessary\n// periodic sync or widget-related state.\nself.addEventListener('widgetuninstall', (event) => {});\n\nconst updateWidget = async (event) => {\n// The widget definition represents the fields specified in the manifest.\n    const widgetDefinition = event.widget.definition;\n\n    // Fetch the template and data defined in the manifest to generate the payload.\n    const payload = {\n        template: JSON.stringify(await (await fetch(widgetDefinition.msAcTemplate)).json()),\n        data: JSON.stringify(await (await fetch(widgetDefinition.data)).json()),\n    };\n\n    // Push payload to widget.\n    await self.widgets.updateByInstanceId(event.instanceId, payload);\n}\n\nconst updateName = async (event) => {\n    const name = event.data.json().name;\n\n    // The widget definition represents the fields specified in the manifest.\n    const widgetDefinition = event.widget.definition;\n\n    // Fetch the template and data defined in the manifest to generate the payload.\n    const payload = {\n        template: JSON.stringify(await (await fetch(widgetDefinition.msAcTemplate)).json()),\n        data: JSON.stringify({name}),\n    };\n\n    // Push payload to widget.\n    await self.widgets.updateByInstanceId(event.instanceId, payload);\n}\n\nworkbox.setConfig({ debug: true });\n\n// Fallback to an offline page for navigation requests\nworkbox.routing.registerRoute(\n    ({ request }) => request.mode === 'navigate',\n    async ({ event }) => {\n        try {\n            // Attempt to fetch the requested page from the network\n            return await workbox.strategies.networkFirst().handle({ event });\n        } catch (error) {\n            // Fallback to offline.html if the fetch fails\n            return await caches.match('/offline.html');\n        }\n    }\n);\n\n// Cache other static assets with CacheFirst strategy\nworkbox.routing.registerRoute(\n    ({ request }) =>\n        ['style', 'script', 'image'].includes(request.destination),\n    new workbox.strategies.CacheFirst({\n        cacheName: 'static-assets',\n        plugins: [\n            new workbox.expiration.ExpirationPlugin({\n                maxEntries: 50,\n                maxAgeSeconds: 30 * 24 * 60 * 60, // Cache for 30 days\n            }),\n        ],\n    })\n);\n\nworkbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);"]}